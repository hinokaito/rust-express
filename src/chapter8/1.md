# ジェネリクス
ジェネリクスは、特定の型に依存しない関数や構造体を作るために使います。Rustはコンパイル時に各型の関数がJIT方式[^1]で作成&インライン化[^2]されるので、コストは最小です。

このように、「抽象化を余分なコスト(オーバーヘッドと言います)無しで行う」ことを「ゼロコスト抽象化」と言います。歴史の上に立ったRustの圧倒的な強みの一つです。

## ジェネリクスを使わない場合
```rust
fn i32_add(left: i32, right: i32) -> i32 { left + right }
fn i64_add(left: i64, right: i64) -> i64 { left + right }
fn f32_add(left: f32, right: f32) -> f32 { left + right }
fn f64_add(left: f64, right: f64) -> f64 { left + right }
fn u32_add(left: u32, right: u32) -> u32 { left + right }
```

## ジェネリクスを使う場合
```rust
// Tは受け付ける型です。

// std::ops::Add<>は、計算能力です。

// 数値型にはこれが実装されているので、Tは何でも受け付けるのではなく、
// 計算能力を持つことを条件にします。

// Output = Tで、返えす型を保証します。
// この場合受け付けた型と同じ型を返すことを保証しています。

// このような制約を「トレイト境界」と言います。

fn add<T: std::ops::Add<Output = T>>(left: T, right: T) -> T {
    left + right
}

fn main() {
    // 18_i32の様にすることで、18はi32型であることを明示できる。
    println!("{}", add(18_i32, 22_i32));
    println!("{}", add(88.2, 3.1));
    println!("{}", add(6_u8, 200_u8));
}
```
例は1つですが、境界が増えてきたら`where`を使うことで可読性が高くなります。
```rust
fn add<T>(left: T, right: T) -> T
where
    T: std::ops::Add<Output = T>,
{
    left + right
}

fn main() {
    println!("{}", add(18_i32, 22_i32));
    println!("{}", add(88.2, 3.1));
    println!("{}", add(6_u8, 200_u8));
}
```

[^1]: 必要になったタイミングで作成
[^2]: コード内に実際に展開される