# Option

Rustでは、エラーハンドリングも型で行います。
「エラーは値」というモダンな思想です。Goもこれです。
好きです。

PythonやJavaの様に、try-catchは使いません。というか存在しません。

`Option`型は、値の有無を表現できます。<br>
`Some()`は値があることを表し、`None`は値がないことを表します。

値がある場合にその中身の値を使いたい場合、Some()を剥がす必要があります。剥がす方法はいくつかありますが、最もシンプルなのはmatchを使うことです。

```rust
fn get(n: Option<i32>) -> i32 {
    // 値があれば値を返し、
    // 無ければ0を返します。
    match n {
        // このようにすることで、numにはSome(n)の中身(n)がnumとして扱えます。
        Some(num) => num,
        None => 0,
    }
}

fn main() {
    let x: Option<i32> = Some(10);
    let y: Option<i32> = None;

    println!("{}", get(x)); // 10
    println!("{}", get(y)); // 0
}
```