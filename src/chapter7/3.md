# 剥がし型
たくさんありますが、どれも知識として必須級です。matchは説明済みなので省略します。

## 1. `if let`
成功したときだけ値を使いたい場合
```rust
fn main() {
    let x = "2a";
    let y = "123";

    if let Ok(n) = x.parse::<i32>() {
        println!("{}", n);
    }

    if let Ok(n) = y.parse::<i32>() {
        println!("{}", n);
    }
}
```

## 2. `unwrap()`
中身を直接取り出すメソッドですが、`None`や`Err`だと`panic!`します。危険です。

```rust
fn main() {
    let x: Option<i32> = Some(21);
    let y: Option<i32> = None;

    // ただ剥がしたいとき
    println!("{}", x.unwrap());

    // 失敗時にその型のデフォルト値を与えたい場合
    println!("{}", y.unwrap_or_default());

    // 失敗時にオリジナルのデフォルト値を与えたい場合
    println!("{}", y.unwrap_or(10));

    // 失敗時に特別な処理をしたい場合
    // 後のチャプターで学ぶ「クロージャ」を使います
    println!("{}", y.unwrap_or_else(|| 2*2));
}
```

## 3. `expect()`
エラーメッセージ付きの`unwrap()`<br>
デバッグに強い
```rust
fn main() {
    let x: Option<i32> = None;
    x.expect("数字が入っていないみたいです");
}
```

## 4. `?`演算子
最強のシンタックスシュガーです。<br>
失敗したときに即Errをreturnし、成功したら値をreturnします。<br>
ただし条件として、`?`を使う関数の戻り値と、`?`で扱うエラーの型に互換性が無ければなりません。<br>
個人的に、今覚えてもしょうがないと思うので後々扱いましょう。

## 5. `while let`
Some()やOk()の間ループを回す。

```rust
fn main() {
    let mut v = vec![1, 2, 3, 4, 5];

    // popは後ろから取り出す
    while let Some(n) = v.pop() {
        println!("{}", n);
    }
}
```