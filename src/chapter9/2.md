# ライフタイム注釈
ライフタイムは、`'a`で表します。

## ライフタイム注釈とは
**「複数の参照の寿命がどう関係しているか」** をコンパイラに教えるもの。参照の寿命を変えるものではない。

## ライフタイム注釈が必要な最小例
コンパイラは賢いですから、自動的にライフタイムを推論してくれますが、どっちの参照が長く生きるのかわからないケースがあります。<br>
最たる例として、参照型を複数受け取って、それをそのまま返したいケースです。例として`&str`を使いますが、参照の型(`&String`, `&i32`やオリジナル列挙型/構造体等でも)であれば同じです。

```rust
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let x = "Rust";
    let y = "Python";

    println!("{}", longest(x, y));
}
```
これはエラーになります。理由を言葉にすると、「戻り値の &str は、x を借りているの？ それとも y ？ 呼び出し元で x と y の寿命が違ったら、戻り値はいつまで有効なの？」<br>
実行してみてください。コンパイラが丁寧に教えてくれると思います。

**ライフタイム注釈をつけてみましょう**
```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let x = "Rust";
    let y = "Python";

    println!("{}", longest(x, y));
}
```

1. `<'a>`: これから`'a`というライフタイムの名前を使う宣言
2. `x: &'a str, y: &'a str`: 引数xとyは、少なくとも`'a`という期間は生きているという意味
3. `-> &'a str`: 戻り値の参照も、少なくとも`'a`と同じ期間は生きているという意味。

慣例的に`'a`が使われますが、`'b`でもなんでもOKです。

