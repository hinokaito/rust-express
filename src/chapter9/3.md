# 'static
## 'staticとは
プログラムが実行されている間、ずっとメモリ上に存在し続ける参照のことです。通常の参照はスコープ内や関数内という一時的な寿命なのに対して、`'static`はプログラムの開始から終了までです。

## 例1. 境界にしたいとき
`'static`を境界にすることで、一時的な寿命(つまり`&`のついた型)を拒否します。
```rust
fn print<T>(p: T)
where
// 'staticであることとと、Displayを実装していることを条件に
    T: 'static + std::fmt::Display, 
{
    println!("{}", p);
}

fn main() {
    // 暗黙的にこれらは'staticを満たす
    
    let a = 32;
    let b = "Rust";
    let c = String::from("Lifetimes");

    print(a);
    print(b);
    print(c);
}
```

もし一時的な寿命で渡してしまうと
```rust
fn print<T>(p: T)
where
    T: 'static + std::fmt::Display, 
{
    println!("{}", p);
}

fn main() {
    let a = 32;
    let b = "Rust";
    let c = String::from("Lifetimes");

    print(&a);
    print(&b);
    print(&c);
}
```


## 例2. 戻り値をゼロコストにしたい
例えば戻り値で文字列を返したいとき、毎回`String::from()`で`String`を返すのは高コストです。以下の流れが発生してしまいます。

1. メモリ上のヒープ領域に新しいスペースを予約
2. 文字を1文字ずつコピーしてそこに書き込む
3. その新しいデータの所有権を呼び出し元に渡す
4. 使い終わったらメモリを開放する

例えば1億回呼び出すとそれがボトルネックになり得ます。

一方、`'static`の場合、メモリの確保やコピは行われず、プログラムの最初からあるデータを指すだけで、オーバーヘッドはありません。

```rust
enum Direction {
    North,
    East,
    South,
    West
}

fn dir_ja(dir: Direction) -> &'static str {
    match dir {
        // わざわざ文字を新しく作らない
        Direction::North => "北",
        Direction::East  => "東",
        Direction::South => "南",
        Direction::West  => "西",
    }
}

fn main() {
    let dir = Direction::East;

    println!("{}", dir_ja(dir));
}
```
