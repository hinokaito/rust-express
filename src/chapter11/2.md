# 動的ディスパッチ
## 裏側の仕組み
### dynもサイズを固定させたい
前提として`dyn Trait`は基本的に参照(ポインタ)である必要があります(とはいえ普通の参照とは異なります)。

> [!NOTE]
> そういえば、ポインタについて説明したことがありませんでしたね。素晴らしい解説があるので参考にしてください。[C言語のポインタを日本一わかりやすく解説する〜導入編〜](https://qiita.com/nishiwakki/items/6757de7d3e4c1a72d546)

なぜかというと、型によってサイズが異なるからです。例として、`i32`は32/8で4バイトですし、Stringは24バイトです。もっと言えば、構造体はStringのフィールドが1000個あるかもしれませんよね。そのインスタンスが急に死にます。

コンパイラは、スタックに変数を置くときにサイズを確定させたいし、しないとやりません。なぜかというと、それは構造体などで1GBのサイズかもしれないからです。`dyn`だとそれがコンパイル時に確定しないので、コンパイル時に食い止めることはできません。

> [!NOTE]
> 実はRustのスタックは、Windowsの場合1スレッド当たり1MBしか使えないのです。ポインタ(参照型)は確実にスタックに積まれますが、その実態はスタック上の場合もあれば、ヒープ上の場合もあります。ただし、スタック上に積まれるのは常に「コンパイル時にサイズが確定するデータ」のみです。

そこでポインタです。ポインタのサイズは常に一定(64bitのCPUなら8バイト)ですから、安全にスタックに積むことができるのです。

### ファットポインタ
しかし前述の普通のポインタでは情報量が足りません。「どの関数？」というのも必要だからです。通常、コンパイラが「その構造体ならそのメソッドのアドレスはここだよね」と確定してくれます。しかし動的ディスパッチだと当然不可能なので、データは増えますが必須なのです。

通常のポインタは「データの場所」だけを持つので、前述の通り8バイトでした。しかし、`&dyn Trait`は16バイトもあります。倍の太さがあるのでファットポインタと呼びます。

ファットポインタの中身は2つです。
1. `data`: 実際のデータがある場所へのポインタ
2. `vptr`: そのデータ専用のVtable(仮想関数テーブル)へのポインタ

### Vtable
Vtableは、コンパイル時にRustが各型ごとにこっそり作成する **関数対応表** です。ToString トレイトを実装している場合、コンパイラはメモリのどこか（静的領域）に以下のような表を作ります。

i32 用の Vtable（イメージ）:
| 項目 | 内容 |
| :--- | :--- |
| デストラクタ | i32 をメモリから消すための関数 |
| サイズ | 4バイト |
| アライメント | 4バイト |
| to_string | impl ToString for i32 で定義された具体的な関数のアドレス |

### 流れ
1. ファットポインタを見る
2. Vtableを見る
3. 関数へジャンプ
4. 実行

## 動的ディスパッチを実体として使いたい
言い換えると、ポインタではなく所有権を持たせて使いたい場合です。

ついにスマートポインタに触れる時が来ました。汎用性最強の`Box<T>`です。

**スタック上にはポインタだけ置き、実体はヒープに置きます。** その実態の所有者はポインタなので、実質的に所有権を扱うことができます。

```rust
fn print_owned(value: Box<dyn ToString>) {
    println!("{}", value.to_string());
}

fn main() {
    // 疑似言語: ToStringトレイトを実装した何かの住所入った箱
    let val: Box<dyn ToString> = Box::new(10);

    print_owned(val); // move
    print_owned(val);
}
```

次のページで`Box`を深堀しましょう