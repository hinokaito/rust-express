# Box<T>
## スタックとヒープ
改めてスタックとヒープについて考えましょう。
```python
# ヒープ
heap = {
    1: "sdiandiajio",
    2: "asdawadsa",
    3: "oisifojifiosd",
    4: "pdfsoifjsijf",   
    # ...
    1000000: "rust"
}

# スタック
stack = {
    #1: i32の変数xなど
    10: heap[1000000],
}

# 10と定義したが、実際には"rust"と定義してると思ってほしい
# 10は、自動的に割り当てられたスタックの番地と仮定
language = 10 
# この時初めてヒープの1000000番地に"Rust"が格納されたとします

print(stack[language]) # rust
```

Pythonで書いてみました。ヒープには大量のデータが入っており、かつランダムに割り当てられます。

一方、スタックは最小限のデータしかありません。しかも順番に入れられるので、変数宣言などはある程度密集しています。

そんなヒープですが、アドレス(この場合キー)さえわかっていれば一瞬でアクセスできますよね？そのため、スタックにアドレスを入れてヒープに実体をいれるのです。

さらに、スタックはサイズが限られていて、Windowsの場合1MBのサイズに制限されています。しかもコンパイル時にサイズを確定する必要があります。逆の視点でいえば、ヒープは制限が「物理的に許す限り」で、かつ入れるデータのサイズを確定する必要がない(つまり動的)のです。

## Boxの役割
お察しの通り、Boxは「データをヒープ(巨大倉庫)に放り込み、その場所を書いたアドレスだけをスタック(手元)に持つ」仕組みです。大きなデータを確保したいときや、データのサイズが確定しないときに有用すぎます。

```rust
fn main() {
    let x = 5;           // スタックに5がある
    let y = Box::new(5); // ヒープに5を置き、スタックにはそのアドレスがある
}
```

嬉しいのは、 **Box(ポインタ)のサイズは常に8バイト** ということです。ある意味、コンパイラを騙すことができます。1GBのデータも、「8バイトだよ」とスタックに保存させます。

## スマートポインタ
前のページでいった通り、`Box`は **スマートポインタ** の一つです。スマートポインタは、通常のポインタのように振る舞いながら、追加の機能を持つ特殊なデータ構造です。

追加の機能を見てみましょう。
1. Deref(参照外し)トレイト
    先ほどのコードの`y`はポインタですが、あたかもデータそのもののように扱うことができます。`*y`とすれば、ポインタを辿ってヒープ上の値にアクセスできます。
2. Dropトレイト
    `y`がスコープ(`}`)を抜けて不要になったとき、RUstは自動的に`Box`の後片付け(デストラクタ)を呼び出します。スタック上のアドレスだけでなく、実際にヒープ上のデータまで掃除します。

## マトリョーシカ問題
代表的なBoxの使用例の連結リストです。このような構造体のサイズは再帰的に無限になってしまいます。
```rust
struct Matryoshka {
    size: u32,
    next: Option<Matryoshka>
}
```

Boxを使うことで簡単に解決できます。
```rust
struct Matryoshka {
    size: u32,
    next: Option<Box<Matryoshka>>
}

fn main() {
    let m = Matryoshka {
        size: 3,
        next: Some(Box::new(Matryoshka {
            size: 2,
            next: Some(Box::new(Matryoshka {
                size: 1,
                next: None
            }))
        }))
    };
}
```