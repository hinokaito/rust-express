# 静的ディスパッチと動的ディスパッチとは？

## 静的ディスパッチ
ジェネリクスを思い出してください。

```rust
// ToStringトレイトは.to_string()メソッドを持っています
fn print_static<T: ToString>(value: T) {
    println!("{}", value.to_string());
}

fn main() {
    print_static(10);      // 整数
    print_static("Hello"); // 文字列
}
```

ジェネリクスの説明のとき、 **インライン化** されるというのを説明しました。実際にコンパイル後の生成されたコードはこのようになっているでしょう。

```rust
fn print_static_for_i32(value: i32) {
    println!("{}", value.to_string());
}

fn print_static_for_str(value: &str) {
    println!("{}", value.to_string());
}

fn main() {
    print_static(10);      // 整数
    print_static("Hello"); // 文字列
}
```

このように、実行時には通常の関数のように使われているのです。
まさに「ゼロコスト」なのです。

## 動的ディスパッチ
`dyn`というキーワードを使用することで動的ディスパッチにすることができます。主に`Trait`に付け使用します。これを`dyn Trait`といいます。
```rust
fn print_dynamic(value: &dyn ToString) {
    println!("{}", value.to_string())
}

fn main() {
    print_dynamic(&10);
    print_dynamic(&"Hello");
}
```
ここでは「型消去」が起きます。コンパイラはvalueの具体的な型を忘れ、ただ「ToStringトレイトを実装している何か」として扱います。実行時に初めて「あ、これは i32 のデータだから、i32 用の to_string を呼ぼう」と判断して使用します。インライン化はされません。

どのように使用するのでしょうか？vtable(仮想関数テーブル)を使用することで実行します。次のページで動的ディスパッチを深く学びましょう。

## つまり
動的ディスパッチは型を無視するため、「一つのコレクション」に異なる型を混ぜることが可能になります。

### メリット・デメリット
- 静的ディスパッチはインライン化され、型は必ず固定されます。
    - メリット
        - 高速
        - ゼロコスト抽象化
    - デメリット
        - バイナリサイズが肥大化
        - 型が固定

- 動的ディスパッチはインライン化されず、型は固定されません。
    - メリット
        - 型が自由
        - バイナリファイルが肥大化しない
    - デメリット
        - vtableを介すことがオーバヘッドになる
        - 最適化に制限ができる
